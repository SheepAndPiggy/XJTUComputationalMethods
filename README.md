# 🚀 XJTU计算方法课程C++代码库

## ✨ 作者

**动力工程及工程热物理 S5037 杨牧天**  

[![GitHub](https://img.shields.io/badge/GitHub-@SheepAndPiggy-blue?logo=github)](https://github.com/SheepAndPiggy)
[![Email](https://img.shields.io/badge/Email-danyangpinkpiggy%40gmail.com-red?logo=gmail)](mailto:danyangpinkpiggy@gmail.com)

![License](https://img.shields.io/badge/License-MIT-blue.svg)
![Version](https://img.shields.io/badge/Version-1.0.0-brightgreen.svg)
![Platform](https://img.shields.io/badge/Platform-C%2B%2B%20%7C%20Vscode%20%7C%20Windows11-lightgrey.svg)

---

## 📖 简介

**XJTU计算方法课程C++代码库** 是一个西安交通大学研究生课程——计算方法的算法实现库，为作者练习C++编程以及学习计算方法所写，涉及的算法均在《数值分析》中详细讲解。

这个代码库希望为学习计算方法的同学们提供一个参考，引用需注明来源。

---

## 📦 安装
本代码库需要GCC编译环境和VsCode编辑器，使用时需要将`.vscode`目录下调试配置文件`launch.json`和任务配置文件`tasks.json`中的调试器、编译器可执行文件路径更改为本地对应路径。

<div align="left">
<b>.vscode\launch.json</b>

```json
{
    "miDebuggerPath": "C:\\Program Files\\mingw64\\bin\\gdb.exe", 
}
```

<div align="left">
<b>.vscode\tasks.json</b>

```json
{
    "command": "C:\\Program Files\\mingw64\\bin\\g++.exe", 
}
```

在使用时，通过在`src\main.cpp`中编写代码并编译运行，查看输出结果，也可以复用`chapters`下的工具`utils.cpp`和各章节算法`chapter**.cpp`。

## 🧠 使用示例
通过查看第二章头文件`chapter02.hpp`，可以看到不同样例的简介，其中包含《数值分析》书中课后的计算实习题目和额外的拓展内容。

<div align="left">
<b>include\chapter02.hpp</b>

```cpp
// 测试用例
struct Chapter02Demos{
    static void Demo1();  // 计算实习2.1
    static void Demo11(size_t n = 1000);  // 测试LU分解分解正定矩阵和求解的性能
    static void Demo2();  // 计算实习2.2
    static void Demo21(size_t n = 1000);  // 比较LU分解、楚列斯基分解、改进平方根法的计算速度
    static void Demo3();  // 计算实习2.3
    static void Demo4();  // 计算实习2.4
    static void Demo41();  // 使用吉文斯变换进行QR分解，计算计算实习2.4
};
```

在主文件中运行测试样例4

<div align="left">
<b>src\main.cpp</b>

```cpp
int main(){
    SetConsoleOutputCP(CP_UTF8);  // 强制控制台使用utf-8编码
    Chapter02Demos::Demo4();
    return 0;
}
```

得到输出结果

```shell
利用吉文斯变换进行QR分解结果：
Q矩阵：
   0.333  -0.337   0.288  -0.437  -0.098   0.222   0.665
   0.267   0.912  -0.014  -0.246  -0.118   0.071   0.132
   0.467  -0.150   0.196  -0.141  -0.570  -0.445  -0.423
   0.333   0.066   0.569   0.603   0.058   0.424  -0.117
   0.400   0.025  -0.136   0.378   0.381  -0.621   0.383
   0.467  -0.150  -0.729   0.156  -0.155   0.420  -0.055
   0.333  -0.069   0.064  -0.445   0.692   0.078  -0.445

R矩阵：
  15.000  19.533  20.933  19.933  21.600  21.267  19.800
   0.000   7.446   2.700   2.906   3.099   2.362   1.107
  -0.000   0.000   3.242   3.358   1.688  -0.481  -2.304
  -0.000   0.000  -0.000   3.734   0.741  -1.651  -1.114
   0.000  -0.000  -0.000   0.000   3.230   3.205   3.902
   0.000  -0.000  -0.000  -0.000   0.000   1.980  -0.074
   0.000  -0.000  -0.000  -0.000  -0.000   0.000  -0.979

求解结果：
   1.000   1.000   1.000   1.000   1.000   1.000   1.000
```

## 📂 项目内容
### Chapter02 解线性方程组的直接法

> 本章节实现了列主元LU分解法、平方根法、改进平方根法、三对角矩阵追赶法、基于吉文斯变换的QR分解、基于豪斯霍尔德变换的QR分解

#### 1. 列主元LU分解法
LU分解的过程和高斯消去法相同，其优势在于如果需要计算多个方程组 $Ax=B$ ，则LU分解将分解矩阵L和U保存后可以避免重复计算；此外，进行高斯消去法时常常会将列中绝对值最大的行置于主元的位置，这相当于对A左乘一个置换矩阵 $P$ ，因此求解方程 $Ax=b$ 变为

$$
\begin{aligned}
\text{first step: } & PA = LU \\
\text{second step: } & Ax = P^T LUx = b \\
\text{third step: } & Ly = Pb;~Ux = y
\end{aligned}
$$

在实际计算中，只需要求解两个上下对角阵的方程即可，通过回代很容易求解。LU分解类如下

```cpp
class DoolittleSolver{  // LU分解亦称杜利尔特分解
    public: 
    // lu分解（列主元），返回包含L和U的矩阵和列主元的行索引矩阵
    static luResult luDecompose(const Matrix& mat, bool pivot = false);

    // 根据上或下三角矩阵进行回代，求解方程组的解，返回方程组的解
    static Matrix solveByTri(const Matrix& tri, const Matrix& b, std::string tri_type);
};
```

##### **题目：计算实习2.1**

利用LU分解法求解线性方程组，已知线性方程组

$$
A\mathbf{x} = \mathbf{b}
$$

其中 

$$
A =
\begin{bmatrix}
1.1348 & 3.8326 & 1.1651 & 3.4017 \\
0.5301 & 1.7875 & 2.5330 & 1.5435 \\
3.4129 & 4.9317 & 8.7643 & 1.3142 \\
1.2371 & 4.9998 & 10.6721 & 0.0147
\end{bmatrix}, \quad
\mathbf{b} =
\begin{bmatrix}
9.5342 \\ 6.3941 \\ 18.4231 \\ 16.9237
\end{bmatrix}.
$$

调用程序(`Demo1()`)

```cpp
luResult result = DoolittleSolver::luDecompose(A, true);  // 列主元LU分解

Matrix L = result.LU_mat.lower_tri();
Matrix U = result.LU_mat.upper_tri();
for (int i = 0; i < L.rows; ++i)
    L(i, i) = 1;  // 将L矩阵的对角线元素置为1

Matrix y = DoolittleSolver::solveByTri(L, result.LU_P * b, "low");  // 求解Ly = Pb
Matrix x = DoolittleSolver::solveByTri(U, y, "up");  // 求解Ux = y
```

得到结果

```shell
LU分解矩阵：
   3.413   4.932   8.764   1.314
   0.362   3.212   7.495  -0.462
   0.333   0.683  -6.866   3.280
   0.155   0.318   0.177   0.907


置换矩阵P：
   0.000   0.000   1.000   0.000
   0.000   0.000   0.000   1.000
   1.000   0.000   0.000   0.000
   0.000   1.000   0.000   0.000

求解结果：
   1.000   1.000   1.000   1.000
```

##### 测试：列主元LU分解法（列主元高斯消去法）的计算效率
调用程序(`Demo11`)，得到结果

```shell
矩阵维度：1000
LU分解用时（s）：
1.32033
LU分解法方程组求解用时（s）：
0.0097692
```

将程序`Demo11`中矩阵维度设置为2000，得到结果

```shell
矩阵维度：2000
LU分解用时（s）：
11.2337
LU分解法方程组求解用时（s）：
0.0238054
```

可以看到，相比于高斯分解法，当方程组系数不变时，LU分解可以节省大量的系数矩阵消元时间；同时当矩阵维数增大时，由于LU分解时间复杂度为 $O(n^3)$ ，因此耗时大约增大为8倍，**对于求解大型矩阵，LU分解法并不适用**。

> 注：在实际使用过程中，专业计算库会对矩阵的求解过程进行深度优化并使用并行计算，可大大提升效率（用时约为本项目代码的十分之一）。

#### 2. 平方根法和改进平方根法
对于对称正定矩阵，有楚列斯基分解

$$
A = GG^T
$$

其中 $G$ 为下三角矩阵，对于G的非对角元 $g_{ij}$ ，可以通过 $a_{ij}$ 、 $g_{ik}$ 、 $g_{jk}$ 、 $g_{jj}$ 确定( $0\le k \le j - 1$ )；对于G的对角元 $g_{jj}$ 则需要根据 $a_{jj}$ 、 $g_{jk}$ 进行开方运算得到；矩阵整体通过从上至下，从左至右的迭代求解即可得到。

在使用楚列斯基分解求解对称正定矩阵时（亦称平方根法），过程如下

$$
\begin{aligned}
\text{first step: } & A = GG^T \\
\text{second step: } & Ax = GG^Tx = b \\
\text{third step: } & Gy = b;~G^Tx = y
\end{aligned}
$$

由于楚列斯基分解需要计算n次开方运算，计算机时间成本较大，因此使用改进平方根法，改进平方根法通过LU分解中 $u_{ij}$ 的计算公式，利用 $l_{ik}$ 、 $u_{kj}$ 计算得到( $0\le k \le i - 1$ )，并根据 $LDL^T$ 这一特殊的分解形式得到 $l_{ji}$ 的计算表达式，其本质上是特殊情况的LU分解，由于对称正定带来的特殊性其比标准LU分解具有更少的计算步骤。

在使用 $LDL^T$ 分解求解对称正定矩阵时（亦称改进平方根法），过程如下

$$
\begin{aligned}
\text{first step: } & A = LDL^T \\
\text{second step: } & Ax = LDL^Tx = b \\
\text{third step: } & Lz = b;~Dy = z;~L^Tx=y
\end{aligned}
$$

平方根法和改进平方根法求解类如下

```cpp
class SqrtMethodSolver{
    public:
    // 楚列斯基分解，返回分解后的矩阵G
    static Matrix choleskyDecompose(const Matrix& mat);

    // 改进平方根法，返回分解后的矩阵LU
    static Matrix improvedSqrtDecompose(const Matrix& mat);
};
```

##### **题目：计算实习2.2**
构造一个 $20\times 20$ 的对称正定矩阵 $A$，元素由

$$
A_{ij}=\min(i,j),\quad i,j=1,\dots,20
$$

给出，并进行楚列斯基分解和 $LDL^T$ 分解。

调用程序(`Demo2`)

```cpp
Matrix G = SqrtMethodSolver::choleskyDecompose(A);
Matrix LU = SqrtMethodSolver::improvedSqrtDecompose(A);
```

得到结果

```shell
（G为元素为1的单位下三角矩阵）
（L为元素为1的单位下三角矩阵，D为单位矩阵）
（由于矩阵较大，此处使用文字描述，不做展示）
```

##### 测试：LU分解法、平方根法、改进平方根法计算效率对比
调用程序`Demo21`，得到结果

```shell
矩阵维度：1000
LU分解用时（s）：
1.41472
楚列斯基分解用时（s）：
0.673267
改进平方根法分解用时（s）：
0.699274
```

可以看到楚列斯基分解和 $LDL^T$ 分解用时约为LU分解的一半，与书中结论相符，但楚列斯基分解用时小于 $LDL^T$ 分解，这可能是由于**本项目的矩阵为作者手动实现的数据类型，其数据按行存储在连续内存块中，因此楚列斯基分解中涉及的按行取值相比于 $LDL^T$ 分解的大量按列取值内存命中率更高**，且作者实现的 $LDL^T$ 分解将中间变量 $u_{ij}$ 存储在矩阵的上三角位置，增加了部分内存写入时间，不过经过资料查询，作者找到有力的证据证明楚列斯基分解更优秀的性能。

1. 专业代码库Eigen对 $GG^T$ 分解和 $LDL^T$ 分解进行了基准测试，用时如下表

| solver/size |         8x8 |     100x100 |    1000x1000 |      4000x4000 |     10000x8 |      10000x100 |      10000x1000 |       10000x4000 |
| ----------- | ----------: | ----------: | -----------: | -------------: | ----------: | -------------: | --------------: | ---------------: |
| **LLT**     |        0.05 |        0.42 |         5.83 |         374.55 |      6.79 * |        30.15 * |        236.34 * |        3847.17 * |
| **LDLT**    | 0.07 (x1.3) | 0.65 (x1.5) | 26.86 (x4.6) | 2361.18 (x6.3) | 6.81 (x1) * | 31.91 (x1.1) * | 252.61 (x1.1) * | 5807.66 (x1.5) * |

（表中的 $LL^T$ 即为楚列斯基分解）

2. 论文[PERFORMANCE OPTIMIZATION OF SYMMETRIC FACTORIZATION
ALGORITHMS](https://cs.nyu.edu/~overton/mstheses/tarca/perf_optm_sym_factor.pdf)提到，聚焦在 SPD（对称正定） 情形下，楚列斯基分解比 $LDL^T$ 分解更高效。原因主要为 Cholesky 对 SPD 矩阵不需要进行主元选择，而 $LDL^T$ 为保证数值稳定性往往实现时需要进行主元选择，这将引发 $LDL^T$ 分解的访存更离散、缓存命中率更低、依赖链更长等诸多问题。

#### 3. 三对角追赶法
三对角追赶法计算过程较为简单，可以参考《数值计算》P35。
##### 题目：计算实习2.3

给定一个严格对角占优的三对角对称矩阵，已知n=20，

$$
  A=\begin{bmatrix}
  4 & -1 &        &        &        \\
  -1& 4  & -1     &        &        \\
  & -1 & 4     & \ddots &        \\
  &    & \ddots& \ddots & -1     \\
  &    &       & -1     & 4
  \end{bmatrix}
$$

$$
  \mathbf{b}=(3,2,\dots,2,3)^{\top}.
$$

求解方程组 $Ax=b$ 。

调用(`Demo3`)，输出结果为

```shell
三对角矩阵追赶法求解结果：
1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000   1.000
```

#### 4. 基于吉文斯变换和豪斯霍尔德变换的QR分解

吉文斯变换通过构造矩阵 $P_{1j}$ 不断消去矩阵每列的第j个元素，将矩阵化为上阶梯矩阵，其中构造的参数 $s$ 和 $c$ 要求

$$
c = \frac{x_1}{\sqrt{x_1^2 + x_j^2}} \quad
s = \frac{x_j}{\sqrt{x_1^2 + x_j^2}}
$$

通过将每列主元之后的元素通过如上吉文斯变换转换为0，即可得到上阶梯矩阵

豪斯霍尔德变换通过构造变换矩阵 $H = I - 2uu^T$ ，可证明存在 $Hx=\sigma v$ ，其中 $v$ 为单位向量，只需满足

$$
\sigma = \pm \|x\|_2 \quad
u = \frac{x - \sigma v}{\|x - \sigma v \|_2}
$$

##### 题目：计算实习2.4
利用豪斯霍尔德变换求解方程组

$$
A =
\begin{bmatrix}
5 & 4 & 7 & 5 & 6 & 7 & 5 \\
4 & 12 & 8 & 7 & 8 & 8 & 6 \\
7 & 8 & 10 & 9 & 8 & 7 & 7 \\
5 & 7 & 9 & 11 & 9 & 7 & 5 \\
6 & 8 & 8 & 9 & 10 & 8 & 9 \\
7 & 8 & 7 & 7 & 8 & 10 & 10 \\
5 & 6 & 7 & 5 & 9 & 10 & 10
\end{bmatrix},
\quad
\mathbf{b} =
\begin{bmatrix}
39 \\ 53 \\ 56 \\ 53 \\ 58 \\ 57 \\ 52
\end{bmatrix}.
$$

调用程序(`Demo4`)，得到结果

```shell
利用豪斯霍尔德变换进行QR分解结果：
Q矩阵：
  -0.333   0.337  -0.288   0.437   0.098   0.222   0.665
  -0.267  -0.912   0.014   0.246   0.118   0.071   0.132
  -0.467   0.150  -0.196   0.141   0.570  -0.445  -0.423
  -0.333  -0.066  -0.569  -0.603  -0.058   0.424  -0.117
  -0.400  -0.025   0.136  -0.378  -0.381  -0.621   0.383
  -0.467   0.150   0.729  -0.156   0.155   0.420  -0.055
  -0.333   0.069  -0.064   0.445  -0.692   0.078  -0.445

R矩阵：
 -15.000 -19.533 -20.933 -19.933 -21.600 -21.267 -19.800
   0.000  -7.446  -2.700  -2.906  -3.099  -2.362  -1.107
   0.000   0.000  -3.242  -3.358  -1.688   0.481   2.304
  -0.000  -0.000   0.000  -3.734  -0.741   1.651   1.114
   0.000  -0.000  -0.000   0.000  -3.230  -3.205  -3.902
   0.000  -0.000   0.000  -0.000   0.000   1.980  -0.074
  -0.000  -0.000   0.000  -0.000  -0.000   0.000  -0.979

求解结果：
   1.000   1.000   1.000   1.000   1.000   1.000   1.000
```

##### 测试：利用吉文斯变换求解计算实习2.4
调用程序(`Demo41`)，得到结果

```shell
利用吉文斯变换进行QR分解结果：
Q矩阵：
   0.333  -0.337   0.288  -0.437  -0.098   0.222   0.665
   0.267   0.912  -0.014  -0.246  -0.118   0.071   0.132
   0.467  -0.150   0.196  -0.141  -0.570  -0.445  -0.423
   0.333   0.066   0.569   0.603   0.058   0.424  -0.117
   0.400   0.025  -0.136   0.378   0.381  -0.621   0.383
   0.467  -0.150  -0.729   0.156  -0.155   0.420  -0.055
   0.333  -0.069   0.064  -0.445   0.692   0.078  -0.445

R矩阵：
  15.000  19.533  20.933  19.933  21.600  21.267  19.800
   0.000   7.446   2.700   2.906   3.099   2.362   1.107
  -0.000   0.000   3.242   3.358   1.688  -0.481  -2.304
  -0.000   0.000  -0.000   3.734   0.741  -1.651  -1.114
   0.000  -0.000  -0.000   0.000   3.230   3.205   3.902
   0.000  -0.000  -0.000  -0.000   0.000   1.980  -0.074
   0.000  -0.000  -0.000  -0.000  -0.000   0.000  -0.979

求解结果：
   1.000   1.000   1.000   1.000   1.000   1.000   1.000
```

### Chapter03 解线性方程组的迭代法
#### 1. 雅可比迭代、高斯赛德尔迭代和超松弛迭代

三种迭代方法可写为通用迭代格式

$$
x_{k+1} = Bx_k + g
$$

对于雅可比迭代，有：

$$
B = D^{-1}(E+F),\quad g = D^{-1}b
$$

对于超松弛迭代，有：

$$
B = (D-\omega E)^{-1}[(1-\omega)D+\omega F],\quad g = \omega(D-\omega E)^{-1}b
$$

对于高斯赛德尔迭代，为超松弛迭代 $\omega=1$ 时的特例

当迭代收敛，意味着相邻两步步长差距不大，采取变化量和上一步 $x$ 比值的模长可以得到收敛判据

$$
\left\|\frac{x_{k+1} - x_k }{x_k}\right\| \le \epsilon
$$

该判据由函数`convergenceError`实现

```cpp
double IterationSolver::convergenceError(const Matrix& x_old, const Matrix& x_new){
    double error = norm((x_new - x_old) / x_old);  // 相对误差
    return error;
}
```

当求解成功，意味着方程组残差 $Ax_k-b$ 足够小，因此可以通过判断残差的模长与 $x$ 模长的比值大小判断是否求解成功

$$
\frac{\| Ax_k - b \|}{\|x_k\|} \le \epsilon
$$

该判据由函数`residualNormError`实现

```cpp
double IterationSolver::residualNormError(const Matrix& x){
    double error = norm(A * x - b);
    return error;
}
```

##### 题目：计算实习3.1
用雅可比迭代法和高斯赛德尔迭代法求解方程

$$
A = \begin{bmatrix}
2.52 & 0.95 & 1.25 & -0.85 \\
0.39 & 1.69 & -0.45 & 0.49 \\
0.55 & -1.25 & 1.96 & -0.98 \\
0.23 & -1.15 & -0.45 & 2.31
\end{bmatrix}, \quad
b = \begin{bmatrix}
1.38 \\
-0.34 \\
0.67 \\
1.52
\end{bmatrix}
$$

使误差小于 $10^{-3}$ ，并比较迭代次数 

调用程序(`Demo1`)，得到结果

```shell
...   ...   ...   ...
第21步残差||Ax-b||/||x||：
0.000133206
*****求解收敛！*****
*****求解成功！*****
   0.884  -0.514  -0.086   0.297

...   ...   ...   ...
第15步残差||Ax-b||/||x||：
0.000
*****求解收敛！*****
*****求解成功！*****
   0.884  -0.514  -0.085   0.297
```

可以看到，高斯赛德尔迭代法比雅可比迭代法收敛更快（15 < 21）。

#### 2. 共轭梯度法

共轭梯度法通过将解线性方程的问题转化为极值问题，可以使维度为n的对称正定矩阵在n步内收敛。

共轭梯度法的求解过程如下

```math
\left\{
\begin{aligned}
d^{(0)} &= r^{(0)} = b - A x^{(0)},\\[4pt]
\alpha_k &= \frac{(r^{(k)})^\top d^{(k)}}{(d^{(k)})^\top A d^{(k)}},\\[4pt]
x^{(k+1)} &= x^{(k)} + \alpha_k d^{(k)},\\[4pt]
r^{(k+1)} &= b - A x^{(k+1)},\\[4pt]
\beta_k &= -\,\frac{(r^{(k+1)})^\top A d^{(k)}}{(d^{(k)})^\top A d^{(k)}},\\[4pt]
d^{(k+1)} &= r^{(k+1)} + \beta_k d^{(k)}.
\end{aligned}
\right.
```

##### 题目：计算实习3.2

用共轭梯度法求解线性方程组 (Ax=b)，其中矩阵 (A) 与向量 (b) 定义为：

$$
A =
\begin{pmatrix}
-2 & 1  &        &        &        \\
 1 & -2 & 1      &        &        \\
   & \ddots & \ddots & \ddots &    \\
   &        & 1  & -2 & 1      \\
   &        &    & 1  & -2
\end{pmatrix}_{n\times n},
\qquad
b =
\begin{pmatrix}
-1\\
0\\
\vdots\\
0\\
-1
\end{pmatrix}.
$$

其中 (A) 为三对角 Toeplitz 矩阵，主对角元为 (-2)，上下对角元为 (1)，其余元素为 (0)；向量 (b) 的首尾分量为 (-1)，中间分量为 (0)。

当矩阵阶数 (n) 分别取 (100)、(200)、(400) 时，用共轭梯度法计算并指出结果是否可靠。

调用程序(`Demo2`)，得到结果

```shell
维度为100的共轭梯度法过程共用89步, 残差||Ax-b||/||x||为0.000950882
维度为200的共轭梯度法过程共用151步, 残差||Ax-b||/||x||为0.000988049
维度为400的共轭梯度法过程共用142步, 残差||Ax-b||/||x||为0.000993269
```

可以看到，残差均收敛达到标准（ $<10^{-3}$ ），且步数均小于矩阵维度n。

#### 3. 基于伽辽金原理的迭代法
1. 伽辽金原理的数学含义

设 $A \in R^{n \times n}$ ， $V = \{v_1,v_2,\cdots,v_m\}$ 为 $R^n$ 中的m维子空间，由于

$$
\nabla (\frac{1}{2}x^TAx - b^Tx) = Ax - b
$$

因此求解线性方程组的问题等价为求解 $F(x)=\frac{1}{2}x^TAx - b^Tx$ 的极小值，对于真解 $x^*$ 和近似解 $x$ ，可以近似认为

$$
\begin{aligned}
x^* &= \arg\min\limits_{x \in R^n}F(x) \\
e &= x^* - x
\end{aligned}
$$

因此寻找最优的 $x$ 等价为使得误差 $e$ 最小，而越小的误差e意味着 $F(x)$ 和 $F(x^*)$ 的差值越小，因此问题等价为


```math
\begin{aligned}
\arg \min\limits_{x \in R^n} F(x) &- F(x^*) \\
F(x) - F(x^*) &= \frac{1}{2}x^TAx - b^Tx - \frac{1}{2}x^{* \top}Ax^* + b^T x^* \\
\text{since}~~b &= Ax^* \\
F(x) - F(x^*) &= \frac{1}{2}e^TAe \propto \| e \|_A
\end{aligned}
```


如果近似解 $x \in V$ ，则问题可以进一步简化为使残差 $r=A(x^* - x)$ 正交于 $V$ 的所有基

$$
\begin{aligned}
&\text{def}~~ \phi(x) = \| x^* - x \|_A = (x^* - x)^TA(x^* - x) \\
&\text{since}~~ \frac{d\phi(x+tv)}{dt} = -(x^* - x)^TAv = -r^Tv.\quad \forall v \in V \\
&\text{that}~~ \arg\min\limits_{x\in V}\phi (x) \iff r^Tv_i = 0.\quad \forall v_i \in B,\quad V = spanB
\end{aligned}
$$

2. 思考：共轭梯度法与伽辽金原理的联系

本质上，共轭梯度法也是基于伽辽金原理的原理型方法，不同于一般基于伽辽金原理的算法——例如阿诺尔迪过程需要求解上海森伯格矩阵组成的线性方程组(维度为 $m\times m$ )，共轭梯度法通过构造一组共轭向量 $d_i, d_i\in V_k$ ，通过三项递推公式使得 $r_k \perp V_k$ ，通过不断迭代更新 $V_k$ 求解，其中 $r_k,d_k \in V_{k+1}$ 可以通过数学归纳法证明

$$
\begin{aligned}
&d_0=r_0 \in V_1 = \{r_0\} \\
&\text{if} ~~ d_k,r_k \in V_{k+1} \\
&\text{then}~~ r_{k+1} = b - Ax_{k+1} = r_k - A\alpha_k d_k \in V_{k+2}\\
&\qquad d_{k+1} = r_{k+1} + \beta_k d_k \in V_{k+2}.
\end{aligned}
$$

因此本质上，共轭梯度法为基于伽辽金原理的方法，二者具有共性。

##### 题目：计算实习3.3

给定线性方程组 (A x = d)，其中矩阵 (A) 为分块三对角矩阵

$$
A=\begin{pmatrix}
B & -I &  &  \\
-I & B & -I &  \\
& \ddots & \ddots & \ddots \\
&  & -I & B
\end{pmatrix}_{200\times 200},
$$

这里每个块均为 $10\times10$ 阶矩阵：$B\in\mathbb{R}^{10\times10}$，(I) 为 $10\times10$ 单位矩阵。于是 (A) 由 $20\times20$ 个块组成，总阶数为 (200)。

分块对角元 (B) 为三对角矩阵

$$
B=\begin{pmatrix}
4 & a &  &  &  \\
b & 4 & a &  &  \\
& \ddots & \ddots & \ddots &  \\
&  & b & 4 & a \\
&  &  & b & 4
\end{pmatrix}_{10\times10},
$$

其中参数

$$
a=-1+\delta,\qquad b=-1-\delta,\qquad \delta=0.01.
$$

右端向量由

$$
d = A f,\qquad f=(1,1,\ldots,1)^{\mathsf T}
$$

给出。显然该方程的精确解为

$$
x=f.
$$

可任意选取初始向量 $x^{(0)}$。

调用程序(`Demo3`)

```c++
Chapter03Demos::Demo3(10);
Chapter03Demos::Demo3(20);
```

得到结果：

```shell
循环型阿诺尔迪算法开始！矩阵维度为: 100
初始残差为421.412
第1步残差为1.17651
第2步残差为0.0632076
第3步残差为0.00157015
第4步残差为9.94872e-05
循环型阿诺尔迪算法开始！矩阵维度为: 200
初始残差为845.811
第1步残差为1.71807
第2步残差为0.182956
第3步残差为0.025624
第4步残差为0.00399607
第5步残差为0.000811107
```

可以看到，对于题目中特定结构的矩阵，循环型阿诺尔迪算法收敛速度较快，100维矩阵和200维矩阵收敛步长仅相差一步。

##### 测试：循环型广义极小残余算法
作为同样基于伽辽金原理的广义极小残余算法，其收敛性在一定条件下具有严格的数学证明，因此被广泛应用于大型稀疏线性方程求解，作者实现了广义极小残余算法，具体可参考`chapter03`源代码。

调用程序(`Demo31`)，得到结果

```shell
对基于伽辽金原理的大型数组迭代解法进行测试，A为随机对称正定矩阵，b为[-10,10]随机矩阵：
维度为1000的共轭梯度法过程共用13步, 残差||Ax-b||/||x||为7.97012e-05
循环型阿诺尔迪算法开始！矩阵维度为: 1000
初始残差为1.00335e+11
第1步残差为8.23106e-05
循环型广义极小残余(GMRES)算法开始！矩阵维度为: 1000
初始残差为1.00335e+11
第1步残差为9.45652e-05
```

可以看到，循环型阿诺尔迪算法和循环型广义极小残余算法对于大型对称正定矩阵的求解比共轭梯度法步数更短。

### Chapter04 插值法
#### 1. 拉格朗日插值法和牛顿插值法及其分段实现

拉格朗日插值法与牛顿插值法形式等价，相比于拉格朗日插值法，牛顿插值法更适合修改和多次计算，其基本可以替代一般的拉格朗日插值法，不过为了理解算法原理，首先学习表达式更美观的拉格朗日插值法是具有一定价值的。此外，工业界常用的是 `barycentric Lagrange`，并不是课本最原始那种写法。

由于多项式等距插值当次数较高时存在**龙格现象**，即插值函数在区间两侧会发生数值振荡，因此一般的解决办法为分段低次插值或者采用不等距节点分布例如Chebyshev节点，本节实现分段低次插值的逻辑为先构造任意区间段的插值函数，再将区间分段，每段对应一个插值函数，当实际插值时，通过判断插值点落在哪个区间决定调用哪个插值函数，具体实现如下所示

```c++
class InterpolateTool{
    public:
    InterpolateTool(Matrix x, Matrix y);

    InterpolateResult lagrangeInterpolation(int seg_num = 1);  // 拉格朗日插值函数，返回一个插值函数指针和一个计算截断误差函数的指针
    InterpolateResult newtonInterpolation(int seg_num = 1);  // 牛顿插值函数，返回值同上

    private:
    double n;
    Matrix x;
    Matrix y;

    static double _langrangeFunction(Matrix xs, Matrix ys, double x); // 拉格朗日插值分段计算函数生成器
    static double _newtonFunction(Matrix xs, Matrix ys, double x);  // 牛顿插值分段计算函数生成器

    std::vector<SepInterpolateResult> _sep_function(int seg_num, double (*function)(Matrix, Matrix, double));  // 一个通用的分段插值函数生成器
    InterpolateResult _function(int seg_num, double (*function)(Matrix, Matrix, double));  // 一个通用的插值函数生成器，旨在增加不同插值方法的代码复用性
    double _error(Matrix xs, Matrix ys, double x, double (*function)(Matrix, Matrix, double));  // 一个通用的截断误差函数（截断误差计算不区分插值方法）
};
```

通过这种方式可以实现分段低次插值的基本调度，当`seg_num`取值为1时意味着区间只有一段即不分段插值。

> 注：由于埃米尔特插值等价于重复节点的牛顿插值，因此不在此赘述

#### 2. 三次样条插值
1. 三次样条的来源

书中提到，早期的绘图员用压铁把一条称为样条的富有弹性的细木条或金属条固定在相邻的若干点上，然后沿着样条画下的即为二阶导数连续的三次曲线，作者看到这里是有一点疑问，为什么这样做画下的曲线就是二阶导数连续且是三次的呢？为此作者重新翻看了材料力学书籍，总结出如下证明过程

+ 为什么是三次的？

可以将曲线理解为随位置变化的挠度函数 $\omega(x)$ ，假设杆上存在一个分布力 $q(x)$ ，因此对杆上任意一个微小单元列力平衡方程和弯矩平衡方程可以得到

$$
V(x) - (V(x) + dV) - q(x) = 0 \\
M(x) - (M(x) + dM) + V(x)dx + q(x)dx \cdot \frac{dx}{2} = 0
$$

得到

$$
V^\prime(x) = -q(x) \\
M^\prime(x) = V(x)
$$

因此根据弯矩-曲率方程和曲率-挠度在小挠度下的关系可以得到

$$
M(x) = EI\kappa(x) = EI\omega^{\prime \prime}(x) \\
EI\omega^{\prime\prime\prime\prime}(x) = -q(x)
$$

由于压铁仅在有限点上对细杆进行固定，因此可以认为相邻两个固定点之间不存在分布载荷 $q(x)$ ，即 $q(x) = 0$ ，因此可以得出

$$
\omega^{\prime\prime\prime\prime}(x) = 0,\qquad x \in (x_i,x_{i+1})
$$

因此通过多次积分可以得到挠度分布为三次多项式，即

$$
\omega(x) = ax^3 + bx^2 + cx + d, \qquad x \in (x_i,x_{i+1})
$$

+ 为什么二阶导数连续？

根据材料力学的原理，集中力 $P$ 不会导致弯矩突变，这是由于

$$
0 < M(x_i^+) - M(x_i^-) = \int^{x_i^+}_{x_i^-}{V(x)dx} < P\epsilon 
$$

其中 $\epsilon$ 为一个极小值，由于 $P$ 为常量，因此该值无限趋近于0，根据夹逼定理证得弯矩的连续性。事实上，只有集中弯矩会导致弯矩的突变。

由于弯矩连续，根据弯矩和挠度的关系，挠度的二阶导数因此也必须连续。

##### 题目：计算实习4.1

观察高次插值多项式的龙格现象

调用程序(`Demo1`)，得到结果

```c++
拉格朗日插值（不分段）在x=0.99处的插值结果：
截断误差为：-226249
插值结果为：2195.77
真实结果为：0.0392118
相对误差为：5.59967e+06%

牛顿插值（不分段）在x=0.99处的插值结果：
截断误差为：-226249
插值结果为：2195.77
真实结果为：0.0392118
相对误差为：5.59967e+06%

拉格朗日插值（分10段）在x=0.99处的插值结果：
截断误差为：-0.00028676
插值结果为：0.0392151
真实结果为：0.0392118
相对误差为：0.00828196%

牛顿插值（分10段）在x=0.99处的插值结果：
截断误差为：-0.00028676
插值结果为：0.0392151
真实结果为：0.0392118
相对误差为：0.00828196%

三次样条插值在x=0.99处的插值结果：
插值结果为：0.0392422
真实结果为：0.0392118
相对误差为：0.0775073%
```

可以看到不分段的拉格朗日插值和牛顿插值法在插值区间边界处精度很差，采用分段低次插值可以大大改善这一结果，此外，三次样条插值也可以很好的改善龙格现象。


### Chapter05 函数最优逼近

#### 1. 最优平方逼近

**最优平方逼近**的目的是通过在基底 $\phi_i(x)$ 上构造一个函数 $p = \sum_{i=1}^{n}{\phi_i(x)}$ ，使得 $p$ 具有最小的误差 $\| p-f\|_2^2$ 。特别的，当给定了采样点集 $X$ ，问题转变为最小化采样点处的误差即**最小二乘拟合**，因此可以说，最小二乘拟合是作用在函数空间上的最优平方逼近在离散点上的特例，二者数学方法和表现形式均类似，在课本上已有详细的说明，再次不做赘述。

最优平方逼近问题的核心是如何选取基函数，具体方法见书中P156。当确定了基函数，如果其仅是普通的线性无关函数（例如 $g_k=x^k$ ），则可以通过求解正规方程组得到目标函数在基函数中的各个分量，特别的，如果基函数相互正交，问题可以进一步简化，最优平方逼近函数表达式为

$$
p(x) = \sum_{k=0}^{n}{\frac{(g_k, f)}{(g_k, g_k)}g_k(x)}
$$

请注意该式在最小二乘拟合时一般并不适用，这是因为一些正交基底的正交性仅在连续区间通过积分形式满足，对于离散点并不成立，因此求解正规方程组是**最小二乘拟合的通用方法**。

**类`LeastSquaresApproximator`已经实现了通用扩展，作者实现了k次多项式拟合和勒让德多项式拟合，读者可以通过添加基底生成函数实现更复杂的基函数种类。**

##### 题目：计算实习5.1

给定数据如下表所示，求其最小二乘拟合四次多项式及其误差

| x     | 0.1    | 0.2    | 0.3    | 0.4    | 0.5    | 0.6    | 0.7    | 0.8    | 0.9     |
|-------|--------|--------|--------|--------|--------|--------|--------|--------|---------|
| y     | 5.1234 | 5.3057 | 5.5687 | 5.9375 | 6.4370 | 7.0978 | 7.9493 | 9.0253 | 10.3627 |

调用程序(`Demo1`)，得到结果

```shell
维度为5的共轭梯度法过程共用8步, 残差||Ax-b||/||x||为4.22128e-12
k次多项式拟合结果
5.12345, 5.30555, 5.56885, 5.93733, 6.43733, 7.09757, 7.94915, 9.02555, 10.3626,
误差为：0.000574429

维度为5的共轭梯度法过程共用6步, 残差||Ax-b||/||x||为5.80521e-14
勒让德多项式拟合结果
5.12345, 5.30555, 5.56885, 5.93733, 6.43733, 7.09757, 7.94915, 9.02555, 10.3626, 
误差为：0.000574429
```

可以看到，k次多项式拟合和勒让德多项式拟合均取得了较好的结果，两种方法得到完全相同的拟合结果和误差，是因为它们都在同一个 4 次多项式空间中求最小二乘解，该解是唯一的；差别只在数值稳定性上：**勒让德多项式近似正交，使得矩阵条件数更好，因此共轭梯度法收敛更快（步数更少）。**

#### 2. 最优一致逼近
下面证明书中P163页的部分切比雪夫定理，该定理为最优一致逼近的理论基础。

最优一致逼近可以理解为最小化点集上的最大偏差，即寻找最优拟合函数 $p_n^*(x)$ 使得

$$
\max\limits_{a\le x \le b}|f(x) - p_n^*(x)| = \min\limits_{p_n\in H_n}\max\limits_{a \le x \le b}|f(x) - p_n(x)|
$$

下面是函数空间中的最优一致逼近函数 $p^*_n(x)$ 应该满足的条件——**切比雪夫定理**

设函数 $f(x)$ 在区间 $[a.b]$ 上连续， $p_n(x) \in H_n$ ，则 $p_n(x)$ 是 $f(x)$ 的最优一致逼近函数的充分必要条件是在区间 $[a,b]$ 上至少有 $n + 2$ 个依次为正负的偏差点，即至少有 $n + 2$ 个点

$$
a \le \tilde{x}_0 < \tilde{x}_1 < \cdots < \tilde{x}_{n+1} \le b
$$

使得

$$
f(\tilde{x}_i) - p_n(\tilde{x}_i) = (-1)^i\sigma E = (-1)^i\sigma \| f - p_n\|_{\infty},\quad \sigma=\pm 1;i=(0,1,\cdots,n+1)
$$

**证明：**

下面证明定理的必要性：

设 $p^*(x)$ 为最佳一致逼近，误差函数 $r(x)=f(x)-p^*(x)$ ，其一致范数为 $|r|_\infty=E$ 。记其最大误差点为 $x_0,\dots,x_M$ ，假设 $M<n+1$ 。在逼近空间 $\mathcal P_n=\mathrm{span}\{\phi_0,\dots,\phi_n\}$ 中构造函数

$$
q(x)=\sum_{k=0}^n d_k \phi_k(x),
$$

要求满足

$$
q(x_i)=\operatorname{sign}(r(x_i)),\qquad i=0,\dots,M.
$$

由于未知数 $d_k$ 共有 $n+1$ 个而条件最多 $M+1\le n+1$ 个，因此线性方程组

$$
A d = R,\qquad
R=\bigl(\operatorname{sign}(r(x_0)),\dots,\operatorname{sign}(r(x_M))\bigr)^{\mathsf T}
$$

必有解，从而能选到非零的 $q\in \mathcal P_n$ 。

对任意足够小且正的 $\lambda>0$ ，构造新的逼近

$$
p_\lambda(x)=p^*(x)+\lambda q(x),
\qquad
r_\lambda(x)=f(x)-p_\lambda(x)=r(x)-\lambda q(x).
$$

在每个极值点 $x_i$ 上由于 $q(x_i)=\operatorname{sign}(r(x_i))$ ，有

$$
r_\lambda(x_i)=\operatorname{sign}(r(x_i))(E-\lambda),
\qquad
|r_\lambda(x_i)|=E-\lambda<E.
$$

另一方面，在所有非极值点上原误差满足 $|r(x)|<E$ ，取 $\lambda$ 足够小，使得 $|r(x)-\lambda q(x)|<E$ 恒成立。于是

$$
|r_\lambda|_\infty< E,
$$

这与 $p^*$ 的最优性矛盾。因此极值点个数必须满足 $M\ge n+2$ ，即最佳一致逼近的误差至少在 $n+2$ 个点达到 $\pm E$ 。

关于交错的必要性和余下的证明，可以参考[格罗宁根大学理工学院数学系Marieke Mudde2017年的硕士毕业论文](https://fse.studenttheses.ub.rug.nl/15406/1/Marieke_Mudde_2017_EC.pdf)或者[剑桥大学数学系Part III B06课程的讲义](https://fse.studenttheses.ub.rug.nl/15406/1/Marieke_Mudde_2017_EC.pdf)。

> 本节有关最优一致逼近的算法不进行编程展示，感兴趣的读者可以自行编写。

### Chapter06 数值积分与数值微分

在进行数值积分时，常使用拉格朗日等距节点插值对被积函数进行近似，通过拉格朗日插值函数的阶次分为梯形、辛普森、科茨求积公式，分别对应1，2，4阶。该算法原理较为简单，不过由于高次插值的龙格现象，因此需要对区间进行细分，分别进行积分求和。

由于数值积分和数值微分需要对插值的多项式函数进行积分微分，其主要工作体现在积分微分公式的推导，在算法上实现难度不大，因此作者并未进行编程实现。

### Chapter07 非线性方程（组）的迭代法

#### 1.二分法、简单迭代法、牛顿迭代法和弦割法

非线性方程的常用迭代求解方法主要包括二分法、简单迭代法、牛顿法和弦割法，它们在收敛性与适用条件方面各具特点。二分法基于连续函数在异号区间内必存在零点的性质，通过在满足 $$ f(a)f(b)<0 $$ 的区间上反复对半分割来逐步缩小根的所在范围，具有收敛性有保证、算法稳健等优点，但收敛速度较慢，仅为线性收敛。简单迭代法通过将原方程改写为固定点形式 $$ x=\varphi(x) $$ ，并采用 $$ x_{k+1}=\varphi(x_k) $$ 进行迭代，实现形式十分简洁，但其收敛性完全依赖于所选 $$ \varphi(x) $$ 的性质，当在根附近不能满足 $$ \lvert \varphi'(x^*)\rvert<1 $$ 时可能不收敛或收敛极慢。牛顿法利用切线近似求解，采用迭代格式 $$ x_{k+1}=x_k-\dfrac{f(x_k)}{f'(x_k)} $$ ，在根附近具有二阶收敛，因而收敛速度显著快于线性方法，但要求目标函数可导，且对初始值较为敏感，不合适的初值可能导致发散或收敛到非期望根。弦割法则用两个相邻迭代点的函数值构造割线近似导数，从而在不显式计算导数的前提下实现类似牛顿法的迭代，其迭代格式为 $$ x_{k+1}=x_k-f(x_k)\dfrac{x_k-x_{k-1}}{f(x_k)-f(x_{k-1})} $$ ，收敛阶通常为超线性，速度介于二分法与牛顿法之间，但稳定性也略逊于二分法。总体而言，二分法在稳定性和全局收敛方面最为可靠，牛顿法在局部收敛速度上最为优越，弦割法在“无需导数”与较快收敛之间提供折中方案，而简单迭代法的性能则高度依赖于固定点形式 $$ \varphi(x) $$ 的恰当构造。


作者实现了上述算法，后续可通过加速收敛技术进行扩展。

##### 题目：计算实习7.2
采用简单迭代法、牛顿法、弦割法求解方程

$$
f(x)=x^{6}-5x^{5}+3x^{4}+x^{3}-7x^{2}+7x-20 = 0
$$

在区间[-1,5]上的全部实根。

**解法如下：**

构造迭代格式

$$
\varphi(x)
= \left(5x^{5} - 3x^{4} - x^{3} + 7x^{2} - 7x + 20\right)^{\frac{1}{6}}
$$

导数为

$$
f'(x)
= 6x^{5} - 25x^{4} + 12x^{3} + 3x^{2} - 14x + 7
$$

通过调用使用二分法分割解区间的函数`findAllRootIntervals`，将步长设置为0.01，计算得出在[-1,5]区间内，目标函数仅有一个零点，且该零点位于区间[4.33,4.34]。于是，可以将[4.33,4.34]作为求解区间，将4.335作为初始值对各个迭代法进行测试。

调用程序(`Demo1`)，得到结果

```shell
简单迭代法共用122步
4.33376
牛顿迭代法共用3步
4.33376
弦割迭代法共用4步
4.33376
```

从本次数值实验的结果可以看出，三种迭代方法在求解同一非线性方程时均收敛到相同的近似根 $x \approx 4.33376$ ，在正确性上是一致的，但其收敛效率存在显著差异。简单迭代法在给定精度要求下共迭代 122 步，表明所选取的固定点形式 $\varphi(x)$ 在该根附近仅具有较弱的收敛性，迭代过程表现为缓慢的线性收敛；相比之下，牛顿迭代法仅用 3 步即可达到同一近似解，体现出典型的二阶收敛特征；弦割法在不需要显式导数的前提下，用 4 步达到相同精度，其收敛速度接近牛顿法。综合比较可知，在该问题及所选初始条件下，牛顿迭代法具有最高的收敛效率，弦割法次之，而简单迭代法虽然能够收敛，但在实际计算中的效率明显偏低。


#### 2. 加速收敛技术



